"""
Напишите программу, вычисляющую следующее состояние поля для Game of life.

Поле представляет собой прямоугольник, причём для крайних клеток поля соседними являются
клетки с противоположного конца (поле представляет собой тор).

Формат ввода:

На первой строке указаны два целых числа через пробел -- высота и ширина поля.
В следующих строках подаётся состояние поля. Точка "." обозначает мёртвую клетку, символ "X" − живую.

Формат вывода:
Следующее состояние поля, используя те же обозначения, что использовались на вводе.

P.S.
Итак что от нас хотят:
Дано поле с живыми("Х") и мертвыми (".") клетками. Верхний и нижний ряд, а также крайний левый и крайне
правый столбец граничат между собой. Клетка умирает, если число ее живых соседей не равно 2 или 3.
В клетку зарождается жизнь, если число ее живых соседей ровно 3.
"""


def num_of_neighbors(y, x, y1, x1, lst):
    counter = 0
    if lst[y1][(x1 + 1) % x] == 'X':
        counter += 1
    if lst[(y1 + 1) % y][(x1 + 1) % x] == 'X':
        counter += 1
    if lst[(y1 + 1) % y][x1] == 'X':
        counter += 1
    if lst[(y1 + 1) % y][(x1 - 1) % x] == 'X':
        counter += 1
    if lst[y1][(x1 - 1) % x] == 'X':
        counter += 1
    if lst[(y1 - 1) % y][(x1 - 1) % x] == 'X':
        counter += 1
    if lst[(y1 - 1) % y][x1] == 'X':
        counter += 1
    if lst[(y1 - 1) % y][(x1 + 1) % x] == 'X':
        counter += 1
    return counter


def main():
    y, x = [int(i) for i in input().split()]
    lst = [input() for _ in range(y)]
    lst_next = []
    for y1 in range(y):
        s = '.' * x
        for x1 in range(x):
            num = num_of_neighbors(y, x, y1, x1, lst)
            if lst[y1][x1] == 'X' and (num < 2 or num > 3):
                s = s[:x1] + '.' + s[x1 + 1:]
            elif lst[y1][x1] == '.' and num == 3 or lst[y1][x1] == 'X' and 2 <= num <= 3:
                s = s[:x1] + 'X' + s[x1 + 1:]
        lst_next.append(s)
    return lst_next


if __name__ == '__main__':
    print(*(main()), sep='\n')
